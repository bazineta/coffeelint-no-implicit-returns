// Generated by CoffeeScript 2.2.3
(function() {
  var NoImplicitReturns,
    indexOf = [].indexOf;

  module.exports = NoImplicitReturns = (function() {
    class NoImplicitReturns {
      type(node) {
        return node.constructor.name;
      }

      /**
       * Determines if a code block ends with a pure statement. If it does not,
       * register an error, as this code block will have an implicit return
       * generated.
       */
      visitCode(code, astApi) {
        var expressions, firstLine, isPureStatement, lastExpr, lastExprLine, lastLine;
        // Ignore constructors, as they do not introduce implicit returns.
        if (indexOf.call(this.constructors, code) >= 0) {
          return;
        }
        // Ignore empty functions.
        if (!(expressions = code.body.expressions).length) {
          return;
        }
        lastExpr = expressions[expressions.length - 1];
        // An expression is a pure statement if it jumps(), i.e. contains:
        // return, continue (not in loop), or break (not in a loop or block)
        isPureStatement = lastExpr.jumps();
        firstLine = code.locationData.first_line + 1;
        lastLine = code.locationData.last_line + 1;
        lastExprLine = lastExpr.locationData.first_line + 1;
        // Multi-line but doesn't end with a pure statement
        if (expressions.length > 1 && !isPureStatement) {
          this.errors.push(astApi.createError({
            context: code.variable,
            lineNumber: firstLine,
            lineNumberEnd: firstLine
          }));
        } else if (expressions.length === 1) {
          // Single line that ends with a return
          if (firstLine === lastLine && this.type(lastExpr) === 'Return') {
            this.errors.push(astApi.createError({
              context: code.variable,
              message: 'Explicit return not required for single-line function',
              level: 'warn',
              lineNumber: firstLine,
              lineNumberEnd: firstLine
            }));
          }
          // Single-expression function that spans multiple lines with a leading newline.
          if (firstLine !== lastLine && !isPureStatement && firstLine !== lastExprLine) {
            this.errors.push(astApi.createError({
              message: 'Remove leading newline or add explicit return',
              context: code.variable,
              lineNumber: firstLine,
              lineNumberEnd: firstLine
            }));
          }
        }
      }

      /**
       * Performs a recursive search for the constructor of `classNode`, heavily
       * inspired by `Class.walkBody`. If a constructor is found, it is registered
       * in `this.constructors`.
       */
      visitClass(classNode) {
        classNode.traverseChildren(false, (child) => {
          var assign, i, j, len, len1, ref, ref1, value;
          if (this.type(child) !== 'Block') {
            return;
          }
          ref = child.expressions;
          for (i = 0, len = ref.length; i < len; i++) {
            value = ref[i];
            if (!(this.type(value) === 'Value')) {
              continue;
            }
            if (!value.isObject(true)) {
              continue;
            }
            ref1 = value.base.properties;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              assign = ref1[j];
              if (this.type(assign) === 'Assign') {
                if (assign.variable.base.value === 'constructor') {
                  this.constructors.push(assign.value);
                }
              }
            }
          }
        });
      }

      lintAST(root, astApi) {
        // Visit AST once, registering all constructors.
        this.constructors = [];
        root.traverseChildren(true, (child) => {
          if (this.type(child) === 'Class') {
            this.visitClass(child);
          }
        });
        // Visit AST again, processing all non-constructor functions.
        root.traverseChildren(true, (child) => {
          if (this.type(child) === 'Code') {
            this.visitCode(child, astApi);
          }
        });
      }

    };

    NoImplicitReturns.prototype.rule = {
      name: 'no_implicit_returns',
      level: 'error',
      message: 'Explicit return required for multi-line function',
      description: 'Checks for explicit returns in multi-line functions'
    };

    return NoImplicitReturns;

  }).call(this);

}).call(this);
